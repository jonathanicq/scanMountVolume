# Project Configuration

**Project Name:** scanMountVolume
**Created:** 2026-01-22
**Last Updated:** 2026-01-22
**Status:** Planning

---

## Overview

**Project Description:**
A Python-based tool that scans and catalogs contents of mounted network shares (NFS, SMB/CIFS), storing comprehensive file metadata in a remote MySQL database. Includes a web interface for management, scheduling, and real-time monitoring.

**Project Goals:**
- Scan and catalog network share contents with full metadata
- Detect duplicate files across volumes
- Provide web interface for management and monitoring on port 8056
- Support scheduled and on-demand scans
- Track file changes including deletions over time

---

## Technology Stack

### Backend
- **Language:** Python
- **Version:** 3.10+
- **Web Framework:** FastAPI
- **CLI Framework:** Typer
- **Async Support:** Yes (asyncio, aiofiles)

### Frontend
- **Type:** Server-rendered templates + minimal JavaScript
- **Template Engine:** Jinja2 (FastAPI default)
- **CSS Framework:** Bootstrap 5 or Tailwind CSS
- **JavaScript:** Vanilla JS or Alpine.js (for reactive updates)

### Database
- **Primary Database:** MySQL 8.0+
- **ORM:** SQLAlchemy 2.0 (async support)
- **Migrations:** Alembic
- **Connection:** Remote MySQL server

### Infrastructure & Deployment
- **Container Platform:** Docker
- **Container Registry:** GitHub Container Registry (ghcr.io)
- **CI/CD:** GitHub Actions
- **Deployment:** Docker Compose or standalone container

### Third-Party Libraries
- **python-magic** - MIME type detection
- **hashlib** - File hashing (MD5, SHA256)
- **APScheduler** - Task scheduling
- **uvicorn** - ASGI server for FastAPI
- **python-dotenv** - Environment variable management
- **passlib** - Password hashing for auth
- **pydantic** - Data validation (FastAPI)

---

## Code Style & Standards

### Naming Conventions
- **Files:** snake_case (e.g., `file_scanner.py`)
- **Variables:** snake_case (e.g., `file_count`)
- **Functions:** snake_case (e.g., `scan_volume()`)
- **Classes:** PascalCase (e.g., `FileScanner`)
- **Constants:** SCREAMING_SNAKE_CASE (e.g., `MAX_FILE_SIZE`)

### Formatting
- **Formatter:** Black
- **Configuration:** `pyproject.toml`
- **Max Line Length:** 100 characters
- **Indentation:** 4 spaces

### Linting
- **Linter:** Ruff (fast, replaces flake8, isort)
- **Type Checking:** mypy
- **Configuration:** `pyproject.toml`
- **Pre-commit Hooks:** Yes (pre-commit framework)

### Import Order
1. Standard library
2. Third-party packages
3. Local application imports

---

## Testing Strategy

### Test Types
- [x] Unit Tests
- [x] Integration Tests
- [ ] End-to-End Tests (deferred to v2)
- [ ] Contract Tests
- [ ] Performance Tests (manual for v1)

### Testing Framework
- **Framework:** pytest
- **Async Testing:** pytest-asyncio
- **Fixtures:** pytest fixtures
- **Coverage Tool:** pytest-cov
- **Coverage Threshold:** 80%

### Test Commands
```bash
# Run all tests
pytest

# Run unit tests only
pytest tests/unit/

# Run integration tests only
pytest tests/integration/

# Generate coverage report
pytest --cov=scanmountvolume --cov-report=html

# Run with verbose output
pytest -v
```

---

## Documentation Requirements

### Required Documentation
- [x] README.md with setup instructions
- [x] API documentation (OpenAPI/Swagger - auto-generated by FastAPI)
- [x] Architecture Decision Records (ADRs)
- [x] CHANGELOG.md
- [x] Inline code comments (where necessary)
- [x] Configuration documentation

### API Documentation
- **Tool:** OpenAPI (automatic with FastAPI)
- **Location:** `/docs` (Swagger UI), `/redoc` (ReDoc)

---

## Logging & Monitoring

### Logging
- **Framework:** Python logging (structlog for structured logs)
- **Format:** JSON (for production), Plain text (for development)
- **Log Levels:** DEBUG, INFO, WARNING, ERROR, CRITICAL
- **Sensitive Data Policy:** Never log passwords, tokens, file contents, PII
- **Log Location:** stdout (for Docker), optionally file

### Monitoring
- **Health Check:** `/health` endpoint
- **Metrics:** Basic scan statistics via API
- **Error Tracking:** Logged to stdout/file (Sentry optional for future)

---

## Security Standards

### Authentication & Authorization
- **Method:** Session-based with HTTP Basic Auth
- **Library:** passlib (bcrypt) for password hashing
- **Session:** Server-side sessions (secure cookies)

### Security Checklist
- [x] All secrets in environment variables (never hardcoded)
- [x] .env.example with placeholder values
- [x] .env in .gitignore
- [x] Input validation on all external inputs (Pydantic)
- [ ] HTTPS enforced (reverse proxy responsibility)
- [x] CORS properly configured (localhost only by default)
- [x] SQL injection prevention (SQLAlchemy ORM)
- [x] XSS prevention (Jinja2 auto-escaping)
- [ ] Rate limiting implemented (optional for v1)

---

## Dependency Management

### Package Manager
- **Tool:** pip with pyproject.toml
- **Lockfile:** requirements.txt (generated from pip-compile or pip freeze)
- **Dev Dependencies:** requirements-dev.txt

### Dependency Policy
- Commit lockfiles to version control
- Regular dependency updates (schedule: monthly)
- Security audit command: `pip-audit`

---

## Git Workflow

### Branch Strategy
- **Main Branch:** `master` (production-ready code)
- **Development Branch:** `dev` (active development)
- **Feature Branches:** `feature/descriptive-name`
- **Fix Branches:** `fix/descriptive-name`
- **Hotfix Branches:** `hotfix/descriptive-name`

### Environment-Based Branch Selection
Docker containers automatically pull from the correct branch based on `APP_ENV`:

| APP_ENV | Branch | Purpose |
|---------|--------|---------|
| `production` | `master` | Stable, production-ready releases |
| `development` | `dev` | Active development, testing |

This is handled by `docker-entrypoint.sh` on container startup.

### Commit Standards
- Meaningful commit messages (imperative mood)
- Format: `type: short description` (e.g., `feat: add volume management API`)
- Types: feat, fix, docs, style, refactor, test, chore
- Reference issue numbers when applicable

### Repository
- **Repository Type:** Public
- **Host:** GitHub
- **URL:** https://github.com/jonathanicq/scanMountVolume

---

## Environment Variables

### Environment Mode (Critical)
```bash
# APP_ENV determines which git branch Docker pulls on startup
# Options: production, development
# - production: pulls from 'master' branch, optimized settings
# - development: pulls from 'dev' branch, debug enabled
APP_ENV=development
```

### Required Variables
```bash
# Environment Mode
APP_ENV=development

# Database
MYSQL_HOST=localhost
MYSQL_PORT=3306
MYSQL_USER=scanbot
MYSQL_PASSWORD=your_password_here
MYSQL_DATABASE=scanmountvolume

# Application
APP_SECRET_KEY=your_secret_key_here
APP_PORT=8056
APP_HOST=0.0.0.0
APP_DEBUG=false

# Authentication
AUTH_USERNAME=admin
AUTH_PASSWORD=change_this_password

# Scanning
SCAN_BATCH_SIZE=1000
SCAN_HASH_ALGORITHM=sha256
SCAN_WORKERS=4

# Logging
LOG_LEVEL=INFO
LOG_FORMAT=json

# Git (for Docker auto-update)
GIT_REPO_URL=https://github.com/jonathanicq/scanMountVolume.git
```

---

## Build & Deployment

### Build Commands
```bash
# Install dependencies
pip install -r requirements.txt

# Install dev dependencies
pip install -r requirements-dev.txt

# Build for development
# (no build step needed for Python)

# Run linting
ruff check .

# Run formatting check
black --check .

# Run type checking
mypy scanmountvolume/

# Start development server
uvicorn scanmountvolume.main:app --reload --port 8056

# Start production server
uvicorn scanmountvolume.main:app --host 0.0.0.0 --port 8056 --workers 4
```

### Docker Commands
```bash
# Build Docker image
docker build -t scanmountvolume:latest .

# Run container
docker run -d \
  --name scanmountvolume \
  -p 8056:8056 \
  -v /mnt:/mnt:ro \
  --env-file .env \
  scanmountvolume:latest

# Docker Compose
docker-compose up -d
```

### Deployment Strategy
- **Environment:** Development → Production
- **Deployment Method:** Docker container via CI/CD
- **Registry:** ghcr.io/jonathanicq/scanmountvolume

---

## CI/CD Pipeline (GitHub Actions)

### Pipeline Stages
1. **Lint** - Run Ruff, Black, mypy
2. **Test** - Run pytest with coverage
3. **Build** - Build Docker image
4. **Push** - Push to GitHub Container Registry (on main branch)

### Triggers
- On push to any branch: lint + test
- On push to master: lint + test + build + push
- On pull request: lint + test

---

## Project Structure

```
scanmountvolume/
├── .github/
│   └── workflows/
│       └── ci.yml
├── scanmountvolume/
│   ├── __init__.py
│   ├── main.py              # FastAPI app entry
│   ├── config.py            # Configuration management
│   ├── models/              # SQLAlchemy models
│   ├── api/                 # API routes
│   ├── services/            # Business logic
│   ├── scanner/             # File scanning logic
│   └── templates/           # Jinja2 templates
├── tests/
│   ├── unit/
│   └── integration/
├── docs/
│   └── adr/
├── Dockerfile
├── docker-compose.yml
├── pyproject.toml
├── requirements.txt
├── requirements-dev.txt
├── .env.example
├── .gitignore
├── README.md
├── CHANGELOG.md
├── PROJECT_CONFIG.md
├── PROJECT_SCOPE.md
└── MASTER_PLAN.md
```

---

## Performance Considerations
- **Database Indexing:** Index on file path, hash, volume_id, is_deleted
- **Batch Inserts:** Insert files in batches of 1000 records
- **Connection Pooling:** SQLAlchemy connection pool (pool_size=5, max_overflow=10)
- **Async I/O:** Use aiofiles for file operations where beneficial
- **Memory Management:** Stream large directories, don't load all into memory

---

## Additional Notes
- Mount points must be accessible from the container/host running the scanner
- For Docker deployment, mount network shares into container with read-only access
- Web interface designed for single-user/admin use (basic auth sufficient)
- Consider reverse proxy (nginx) for HTTPS in production

---

## Decision Lock
**These decisions are locked for this project.** Any changes require explicit approval and must be documented with rationale in an ADR.

**Locked on:** 2026-01-22
**Approved by:** [Pending]
